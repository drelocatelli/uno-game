"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketControllers = void 0;
const socket_io_1 = require("socket.io");
const glob_1 = require("glob");
const path_1 = require("path");
const SocketControllerMetaKey_1 = require("./types/SocketControllerMetaKey");
const path_to_regexp_1 = require("path-to-regexp");
const HandlerType_1 = require("./types/enums/HandlerType");
const SocketEventType_1 = require("./types/enums/SocketEventType");
const ParameterType_1 = require("./types/enums/ParameterType");
const ResultType_1 = require("./types/enums/ResultType");
const get_metadata_1 = require("./util/get-metadata");
const defaultTransformOptions_1 = require("./types/constants/defaultTransformOptions");
const class_transformer_1 = require("class-transformer");
class SocketControllers {
    constructor(options) {
        this.options = options;
        this.container = options.container;
        this.io = options.io || new socket_io_1.Server(options.port);
        this.transformOptions = {
            ...defaultTransformOptions_1.defaultTransformOptions,
            ...options.transformOption,
        };
        this.controllers = this.loadHandlers(options.controllers || [], HandlerType_1.HandlerType.CONTROLLER);
        this.middlewares = this.loadHandlers(options.middlewares || [], HandlerType_1.HandlerType.MIDDLEWARE);
        this.registerMiddlewares();
        this.registerControllers();
    }
    loadHandlers(handlers, type) {
        const loadedHandlers = [];
        for (const handler of handlers) {
            if (typeof handler === 'string') {
                loadedHandlers.push(...this.loadHandlersFromPath(handler, type));
            }
            else {
                loadedHandlers.push(handler);
            }
        }
        return loadedHandlers.map(handler => {
            return {
                metadata: (0, get_metadata_1.getMetadata)(handler),
                target: handler,
            };
        });
    }
    loadHandlersFromPath(path, handlerType) {
        const files = (0, glob_1.sync)((0, path_1.normalize)(path).replace(/\\/g, '/'));
        return files
            .map(file => require(file))
            .reduce((loadedFiles, loadedFile) => {
            const handlersInFile = Object.values(loadedFile).filter(fileEntry => {
                if (typeof fileEntry !== 'function') {
                    return false;
                }
                if (!Reflect.hasMetadata(SocketControllerMetaKey_1.SOCKET_CONTROLLER_META_KEY, fileEntry)) {
                    return false;
                }
                return Reflect.getMetadata(SocketControllerMetaKey_1.SOCKET_CONTROLLER_META_KEY, fileEntry).type === handlerType;
            });
            loadedFiles.push(...handlersInFile);
            return loadedFiles;
        }, []);
    }
    registerMiddlewares() {
        const middlewares = this.middlewares.slice().sort((middleware1, middleware2) => {
            return (middleware1.metadata.priority || 0) - (middleware2.metadata.priority || 0);
        });
        const middlewaresWithoutNamespace = middlewares.filter(middleware => !middleware.metadata.namespace);
        const middlewaresWithNamespace = middlewares.filter(middleware => !!middleware.metadata.namespace);
        for (const middleware of middlewaresWithoutNamespace) {
            this.registerMiddleware(this.io, middleware);
        }
        this.io.on('new_namespace', (namespace) => {
            for (const middleware of middlewaresWithNamespace) {
                const middlewareNamespaces = Array.isArray(middleware.metadata.namespace)
                    ? middleware.metadata.namespace
                    : [middleware.metadata.namespace];
                const shouldApply = middlewareNamespaces.some(nsp => {
                    const nspRegexp = nsp instanceof RegExp ? nsp : (0, path_to_regexp_1.pathToRegexp)(nsp);
                    return nspRegexp.test(namespace.name);
                });
                if (shouldApply) {
                    this.registerMiddleware(namespace, middleware);
                }
            }
        });
    }
    registerControllers() {
        const controllersWithoutNamespace = this.controllers.filter(controller => !controller.metadata.namespace);
        const controllersWithNamespace = this.controllers.filter(controller => !!controller.metadata.namespace);
        this.io.on('connection', (socket) => {
            for (const controller of controllersWithoutNamespace) {
                this.registerController(socket, controller);
            }
        });
        const controllerNamespaceMap = {};
        const controllerNamespaceRegExpMap = {};
        for (const controller of controllersWithNamespace) {
            const nsp = controller.metadata.namespace;
            if (!controllerNamespaceMap[nsp]) {
                controllerNamespaceMap[nsp] = [];
            }
            controllerNamespaceMap[nsp].push(controller);
            controllerNamespaceRegExpMap[nsp] = nsp;
        }
        for (const [nsp, controllers] of Object.entries(controllerNamespaceMap)) {
            const namespace = controllerNamespaceRegExpMap[nsp];
            this.io
                .of(namespace instanceof RegExp ? namespace : (0, path_to_regexp_1.pathToRegexp)(namespace))
                .on('connection', (socket) => {
                for (const controller of controllers) {
                    this.registerController(socket, controller);
                }
            });
        }
    }
    registerController(socket, controller) {
        const connectedAction = Object.values(controller.metadata.actions || {}).find(action => action.type === SocketEventType_1.SocketEventType.CONNECT);
        const disconnectedAction = Object.values(controller.metadata.actions || {}).find(action => action.type === SocketEventType_1.SocketEventType.DISCONNECT);
        const disconnectingAction = Object.values(controller.metadata.actions || {}).find(action => action.type === SocketEventType_1.SocketEventType.DISCONNECTING);
        const messageActions = Object.values(controller.metadata.actions || {}).filter(action => action.type === SocketEventType_1.SocketEventType.MESSAGE);
        if (connectedAction) {
            this.executeAction(socket, controller, connectedAction);
        }
        if (disconnectedAction) {
            socket.on('disconnect', () => {
                this.executeAction(socket, controller, disconnectedAction);
            });
        }
        if (disconnectingAction) {
            socket.on('disconnecting', () => {
                this.executeAction(socket, controller, disconnectingAction);
            });
        }
        for (const messageAction of messageActions) {
            socket.on(messageAction.options.name, (...args) => {
                const messages = args.slice(0, -1);
                const ack = args[args.length - 1];
                if (!(ack instanceof Function)) {
                    messages.push(ack);
                }
                this.executeAction(socket, controller, messageAction, messageAction.options.name, messages);
            });
        }
    }
    executeAction(socket, controller, action, eventName, data) {
        const parameters = this.resolveParameters(socket, controller.metadata, action.parameters || [], data);
        try {
            let container = this.container;
            if (this.options.scopedContainerGetter) {
                container = this.options.scopedContainerGetter(this.collectScopedContainerParams(socket, action.type, eventName, data, controller.metadata.namespace));
            }
            const controllerInstance = container.get(controller.target);
            const actionResult = controllerInstance[action.methodName](...parameters);
            Promise.resolve(actionResult)
                .then(result => {
                this.handleActionResult(socket, action, result, ResultType_1.ResultType.EMIT_ON_SUCCESS);
            })
                .catch(error => {
                this.handleActionResult(socket, action, error, ResultType_1.ResultType.EMIT_ON_FAIL);
            });
        }
        catch (error) {
            this.handleActionResult(socket, action, error, ResultType_1.ResultType.EMIT_ON_FAIL);
        }
    }
    handleActionResult(socket, action, result, resultType) {
        var _a, _b;
        const allOnResultActions = ((_a = action.results) === null || _a === void 0 ? void 0 : _a.filter(result => result.type === resultType)) || [];
        const skipOnEmpty = (_b = action.results) === null || _b === void 0 ? void 0 : _b.some(result => result.type === ResultType_1.ResultType.SKIP_EMIT_ON_EMPTY_RESULT);
        if (result == null && skipOnEmpty) {
            return;
        }
        let onResultActions = allOnResultActions;
        if (onResultActions.some(action => action.options.errorType)) {
            const firstFittingAction = allOnResultActions.find(action => action.options.errorType && result instanceof action.options.errorType);
            if (!firstFittingAction) {
                onResultActions = allOnResultActions.filter(action => !action.options.errorType);
            }
            else {
                onResultActions = [firstFittingAction];
            }
        }
        for (const onResultAction of onResultActions) {
            const transformedValue = result instanceof Error
                ? result.message
                : this.transformActionValue(result, null, onResultAction.options, 'result');
            socket.emit(onResultAction.options.messageName, transformedValue);
        }
    }
    registerMiddleware(namespace, middleware) {
        namespace.use((socket, next) => {
            const instance = this.container.get(middleware.target);
            instance.use(socket, next);
        });
    }
    resolveParameters(socket, controllerMetadata, parameterMetadatas, data) {
        const parameters = [];
        for (const metadata of parameterMetadatas) {
            const parameterValue = this.resolveParameter(socket, controllerMetadata, metadata, data);
            parameters[metadata.index] = this.transformActionValue(parameterValue, metadata.reflectedType, metadata.options, 'parameter');
        }
        return parameters;
    }
    resolveParameter(socket, controller, parameter, data) {
        var _a;
        switch (parameter.type) {
            case ParameterType_1.ParameterType.CONNECTED_SOCKET:
                return socket;
            case ParameterType_1.ParameterType.SOCKET_ID:
                return socket.id;
            case ParameterType_1.ParameterType.SOCKET_IO:
                return this.io;
            case ParameterType_1.ParameterType.SOCKET_ROOMS:
                return socket.rooms;
            case ParameterType_1.ParameterType.MESSAGE_BODY:
                return data === null || data === void 0 ? void 0 : data[parameter.options.index || 0];
            case ParameterType_1.ParameterType.SOCKET_QUERY_PARAM:
                return socket.handshake.query[parameter.options.name];
            case ParameterType_1.ParameterType.SOCKET_REQUEST:
                return socket.request;
            case ParameterType_1.ParameterType.NAMESPACE_PARAMS:
                return this.extractNamespaceParameters(socket, controller.namespace, parameter);
            case ParameterType_1.ParameterType.NAMESPACE_PARAM:
                return (_a = this.extractNamespaceParameters(socket, controller.namespace, parameter)) === null || _a === void 0 ? void 0 : _a[parameter.options.name];
        }
    }
    transformActionValue(value, reflectedType, options, transformType) {
        var _a, _b, _c;
        const transformOptions = {
            transform: (_a = options.transform) !== null && _a !== void 0 ? _a : this.transformOptions.transform,
            parameterTransformOptions: (_b = options.transformOptions) !== null && _b !== void 0 ? _b : this.transformOptions.parameterTransformOptions,
            resultTransformOptions: (_c = options.transformOptions) !== null && _c !== void 0 ? _c : this.transformOptions.resultTransformOptions,
        };
        if (!transformOptions.transform) {
            return value;
        }
        if (typeof value !== 'object' || Array.isArray(value) || value == null) {
            return value;
        }
        if (transformType === 'parameter') {
            return (0, class_transformer_1.plainToInstance)(reflectedType, value, transformOptions.parameterTransformOptions);
        }
        if (transformType === 'result') {
            return (0, class_transformer_1.instanceToPlain)(value, transformOptions.resultTransformOptions);
        }
        return value;
    }
    collectScopedContainerParams(socket, eventType, eventName, messageBody, namespace) {
        return {
            eventType,
            eventName,
            socket,
            socketIo: this.io,
            nspParams: this.extractNamespaceParameters(socket, namespace),
            messageArgs: messageBody,
        };
    }
    extractNamespaceParameters(socket, namespace, parameterMetadata) {
        const keys = [];
        const regexp = namespace instanceof RegExp ? namespace : (0, path_to_regexp_1.pathToRegexp)(namespace || '/', keys);
        const parts = regexp.exec(socket.nsp.name) || [];
        const params = {};
        keys.forEach((key, index) => {
            var _a;
            params[key.name] = ((_a = parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.options) === null || _a === void 0 ? void 0 : _a.transform)
                ? this.transformActionValue(parts[index + 1], parameterMetadata.reflectedType, parameterMetadata.options, 'parameter')
                : parts[index + 1];
        });
        return params;
    }
}
exports.SocketControllers = SocketControllers;
//# sourceMappingURL=SocketControllers.js.map